/*
 * Zest JS
 * zestjs.org
 *
 *  -InstanceChains
 *  -Options
 *  -Pop
 *  -Component
 *  -Regions
 *  
 * 
 */
//allow this to be loaded as an amd or global
(function (root, factory) {
  // AMD. Register as an anonymous module.
  if (typeof define === 'function' && define.amd)
    define(['module', './render', './object', 'selector', 'css'], factory);
  // Browser globals
  else
    root.$z = factory({
      config: function() {}
    }, null, null,
        window.jQuery || window.$ || function(selector, context) {
      return context.querySelectorAll(selector);
    }, {
      add: function(css) {
        if (this.stylesheet === undefined) {
          this.stylesheet = document.createElement('style');
          this.stylesheet.setAttribute('type', 'text/css');
          document.getElementsByTagName('head')[0].appendChild(this.stylesheet);
        }
        this.stylesheet.innerHTML += css;
      }
    });
}(this, function (module, render, object, $, css) {
if (object && render) {
  $z = object;
  $z = $z.overwrite($z, render);
}

var client = typeof window !== 'undefined' && typeof window.location !== 'undefined';
 
/*
 * $z.Component
 * Creates a component with rendering or as attach-only
 *
 * The component is entirely rendered by $z.render.
 *
 * Attachment::
 *
 * Attachment is triggered when a "$$" element array options parameter is provided to the constructor.
 * This is the consecutive DOM elements currently definining the rendered widget to attach.
 *
 * Attachment::
 *
 * Components attach based on the options.attach specification.
 *
 * Example:
 *
 *  options.attach = {
 *    Component: '#[component]$', //dollar sign indicates only finding components directly inside this region
 *    $element: '#an-element',
 *    region: '.a-region'
 *  }
 *
 * If there is more than one match, an error is thrown.
 *
 * The DOM element being attached is then checked to see if it is a component or dynamic region
 * (featuring a 'component' or 'region' attribute)
 * If it is a component, it is attached from its $z property
 * If it is a region, it is dynamically built from the region wrapper.
 *
 * The notation of $element, region (small letter) and Component (capital) is a highly recommended convention.
 * There is no consequence for failing to follow this though.
 *
 *
 * Disposal::
 *
 * The dispose method is automatically appended with functionality to remove the
 * html elements generated by the template from the DOM.
 *
 * If the component adds any other DOM elements, it must include their removal
 * in a dispose hook.
 *
 * *More importantly, ALL events registered by the component should be manuallly
 * removed by a dispose method.
 *
 * Suggested syntax (with jQuery as an example):
 *
 * functionInstances: ['click'], //ensures that the click event is bound to this and unique to this
 * construct: function() {
 *   this.$el.click(this.click);
 *   this.dispose.on(function() {
 *     this.$el.unbind('click', this.click);
 *   });
 * }
 * 
 * This is very important for removing memory leaks.
 * 
 *
 * NB Never use a pre-constructor override with the Create functionality. This could
 *    interfere with having all creation logic handled by the template and structure
 *    methods.
 *
 */

var dynamic = false;
$z.Component = $z.creator({
  
  implement: [$z.constructor, $z.Options, $z.InstanceChains, $z.Pop],
  
  _extend: {
    pipe: $z.extend.CHAIN,
    template: $z.extend.REPLACE,
    construct: $z.extend.CHAIN,
    prototype: $z.extend,
    css: function(a, b) {
      var funcify = function(str) {
        return function() {
          return str;
        }
      }
      if (typeof a == 'function' && a.run) {
        a.on(b);
        return a;
      }
      else if (typeof a == 'string')
        a = funcify(a);
      if (typeof b == 'string')
        b = funcify(b);
        
      var f = $z.fn($z.fn.createRunFunction(function(a, b) {
        return a + b;
      }, ''));
      f.on(b);
      return f;
    },
    attachExclusions: $z.extend.ARR_APPEND,
    'prototype.dispose': $z.extend.CHAIN
  },
  
  attach: function($$, options) {
    options.$$ = $$;
    new this(options);
  },
  
  make: function() {
    dynamic = false;
  },
  integrate: function(def) {
    if (dynamic)
      return;

    if (def.construct || def.dynamic === true)
      dynamic = true;
      
    if (def.prototype)
      for (p in def.prototype) {
        dynamic = true;
        return;
      }
  },
  built: function() {
    if (!dynamic)
      delete this.attach;
  },
  
  construct: function(options) {
    if (!options.$$)
      throw 'No template defined for component creation.';

    this.$$ = options.$$;
    delete options.$$;
    
    this.$$[0].$z = this;
  },
  prototype: {
    $: function(selector) {
      var matches = $(selector, this.$$[0].parentNode);
      var filtered = [];
      for (var i = 0; i < matches.length; i++) {
        var ownerComponent = $z.getComponent(matches[i]);
        if (ownerComponent == this)
          filtered.push(matches[i]);
      }
      return filtered;
    },
    $z: function(selector) {
      var matches = $z(selector);
      if (!(matches instanceof Array))
        matches = [matches];
      
      function getParentPossibilities(component, parents) {
        parents = parents || [];
        
        var prevNode = component.$$[0];
        
        while (prevNode = prevNode.previousSibling) {
          if (prevNode.$z)
            break;
        }
        if (prevNode && prevNode.$z) {
          parents.push(prevNode.$z);
          return getParentPossibilities(prevNode.$z, parents);
        }
        else {
          if (component.$$[0].parentNode == document.body) {
            if (document.body.$z)
              parents.push(document.body.$z);
            return parents;
          }
          else
            parents.push($z.getComponent(component.$$[0].parentNode));
          return parents;
        }        
      }
      var filtered = [];
      for (var i = 0; i < matches.length; i++) {
        var parents = getParentPossibilities(matches[i]);
        
        //if this is a 'possible' parent, give it the benefit of the doubt
        for (var j = 0; j < parents.length; j++) {
          if (parents[j] === this) {
            filtered.push(matches[i]);
            break;
          }
        }
      }
      if (filtered.length == 1)
        filtered = filtered[0];
      return filtered;
    },
    dispose: function() {
      //clear dynamic regions
      //for (var region in this.regions)
      //  this.regions[region].clear();
      
      //clear subcomponents
      var subcomponents = this.$z();
      for (var i = 0; i < subcomponents.length; i++) {
        //ensure we avoid duplicate subcomponent disposal
        if (subcomponents[i].$$)
          subcomponents[i].dispose();
      }
      
      delete this.$$[0].$z;
      
      var parent = this.$$[0].parentNode;
      for (var i = 0; i < this.$$.length; i++)
        parent.removeChild(this.$$[i]);
      
      delete this.$$;
    }
  }
});


/*
 * $z.Region
 *
 * var s = $z.Region(wrapper, [structure]);
 *
 * wrapper is the region wrapper
 * Structure is the optional structure to provide, anything that can go into $z.render is allowed
 *
 * 
 * The region provides the following methods:
 *
 * s.add([DOMArray])
 * s.append(structure);
 * s.remove(index);
 * s.appendAfter(structure, index);
 * s.clear();
 * etc (obviously all reserved words for structure labels!)
 *
 * List can be accessed from numerical properties of the region
 * s.length
 * s[0] etc.
 * 
 */
$z.Region = $z.constructor({
  construct: function(wrapper, structure) {
    this.wrapper = wrapper;
    
    addItems.call(this, parseItems(wrapper.childNodes));
    
    if (structure)
      this.append(structure);
  },
  prototype: {
    append: function(structure, options) {
      var $$ = $z.render(structure, options);
      $z.dom.insert($$, this.wrapper);
      addItems.call(this, parseItems($$));
      return this;
    },
    clear: function() {
      for (var i = 0; i < this.length; i++) {
        
        if (!(this[i] instanceof Array)) {
          //dispose components
          if (this[i].dispose)
            this[i].dispose();
        }
        else {
          //remove DOM elements
          $z.dom.remove(this[i]);
        }
        
        //clear references
        delete this[i];
      }
      this.length = 0;
    },
    remove: function(index) {
      //remove the item at index
      //dispose components
      if (!(this[index] instanceof Array))
        if (this[index].dispose)
          this[index].dispose();
      
      //remove DOM elements
      $z.dom.remove(this[index]);
      
      //clear references
      delete this[index];
      this.length--;
      
      for (var i = index; i < this.length; i++)
        this[i] = this[i + 1];
        
      delete this[this.length];
    },
    appendAfter: function(structure, item) {
      //append the given structure after the label or index "item"
      
    }
  }
});

/*
 * parseItems
 * Private region function to convert a list of DOM nodes into a list of high-level region structure.
 *
 * $$ = 
 *  <div>
 *    just some html
 *  </div>
 *  <div component>
 *  </div>
 *  <h1>still the above component</h1>
 *  <div>some more html</div>
 *
 * Gets converted as
 * [[DOMArray], Component, [DOMArray]]
 *
 */

var parseItems = function($$) {
  var items = [];
  var DOMbuffer = [];
  for (var i = 0; i < $$.length; i++) {
    var z = $$[i].$z;
    if (z !== undefined) {
      if (DOMbuffer.length > 0) {
        items.push(DOMbuffer);
        DOMbuffer = [];
      }
      items.push(z);
    }
    else
      DOMbuffer.push($$[i]);
  }
  if (DOMbuffer.length > 0)
    items.push(DOMbuffer)
  return items;  
}
 
/*
 * addItems
 * Private function to insert the given item list at the given index on the region
 * Expects to be called bound to the region
 */
var addItems = function(items, index) {
  
  if (index === undefined)
    index = this.length - 1;
    
  //first, copy out all the items after index
  var shifted = [];
  for (var i = index; i < this.length; i++)
    shifted.push(this[i]);
  
  //copy in new items
  for (var i = 0; i < items.length; i++)
    this[index + i]  = items[i];
  
  //finally copy back shifted items
  for (var i = 0; i < shifted.length; i++)
    this[index + items.length + i] = shifted[i];
  
  this.length += items.length;
}

return $z;

}));

