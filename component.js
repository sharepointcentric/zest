define(['zoe', 'is!browser?./zest-render'], function(zoe, $z) {
  
  /*
   * Component
   * 
   * Creates a component with rendering or as attach-only
   *
   * The component is entirely rendered by $z.render.
   *
   * Attachment is triggered when a "$$" element array options parameter is provided to the constructor.
   * This is the consecutive DOM elements currently definining the rendered widget to attach.
   *
   * Disposal::
   *
   * The dispose method is automatically appended with functionality to remove the
   * html elements generated by the template from the DOM.
   *
   * If the component adds any other DOM elements, it must include their removal
   * in a dispose hook.
   *
   * *More importantly, ALL events registered by the component should be manuallly
   * removed by a dispose method.
   *
   * Suggested syntax (with jQuery as an example):
   *
   * construct: function() {
   *   this.$el.click(this.click);
   *   this.dispose.on(function() {
   *     this.$el.unbind('click', this.click);
   *   });
   * }
   * 
   * This is very important for removing memory leaks.
   *
   * The default '_unbind' property on the constructor automatically unbinds jquery events
   * when jQuery is bound to the contextual selector
   *
   */
  
  // only allow the first function to stop execution (used by dispose)
  zoe.fn.STOP_FIRST_DEFINED = function(self, args, fns) {
    var output = fns[0].apply(self, args);
    if (output !== 'undefined')
      return;
    for (var i = 1; i < fns.length; i++)
      fns[i].apply(self, args);
  }
  var Component = {
    _implement: [zoe.Constructor],
    
    _extend: {
      options: 'APPEND',
      type: 'REPLACE',
      pipe: 'CHAIN',
      load: zoe.extend.makeChain('ASYNC'),
      'prototype.dispose': zoe.extend.makeChain(zoe.fn.STOP_FIRST_DEFINED)
    },
    
    attach: function(o, els) {
      return new this(o, els);
    },
    
    construct: function(o, els) {
      if (!els)
        return $z.render(this.constructor, o, document.createDocumentFragment());
      this.o = o;
      this.$$ = els;
    },
    
    _unbind: true,
    prototype: {
      $: $z && $z.$,
      $z: $z && $z.$z,
      dispose: function(system) {
        //cut out and call $z.dispose to do the work, it will call this back with the system flag
        //basically, $z.dispose(el) is the right method.
        //   component.dispose(true) does 'extra' disposal.
        //   everything else is in $z.dispose, hence we revert to it by convenience
        if (!system) {
          $z.dispose(this.$$);
          return true;
        }        
        //automatically unbind jquery events on the elements
        if (this.constructor._unbind && $z.$.fn && $z.$.fn.jquery)
          this.$('*').unbind(); 
        delete this.$$;
      }
    } 
  };
  
  return Component;
});